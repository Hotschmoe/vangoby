<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEV Bot Network Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 20px;
            background: rgba(15, 15, 35, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff, #00a8ff, #7b68ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .node-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            color: #a0aec0;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            box-shadow: 0 0 10px #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            position: absolute;
            top: 100px;
            right: 20px;
            z-index: 1000;
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 280px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.9rem;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .btn {
            background: linear-gradient(135deg, #00d4ff, #00a8ff);
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            font-size: 0.9rem;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 300px;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: rgba(15, 15, 35, 0.8);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #00d4ff;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #a0aec0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #network-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 500;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 212, 255, 0.3);
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(239, 68, 68, 0.3);
            margin-top: 10px;
            font-size: 0.85rem;
        }

        .tooltip {
            position: absolute;
            background: rgba(15, 15, 35, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.85rem;
            z-index: 2000;
            pointer-events: none;
            backdrop-filter: blur(10px);
            max-width: 250px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ¤– MEV Bot Network Visualization</h1>
        <div class="node-status">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="nodeStatus">Connecting to local Erigon node...</span>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="blockRange">Block Range</label>
            <select id="blockRange">
                <option value="10">Last 10 blocks</option>
                <option value="25">Last 25 blocks</option>
                <option value="50" selected>Last 50 blocks</option>
                <option value="100">Last 100 blocks</option>
            </select>
        </div>

        <div class="control-group">
            <label for="minValue">Min Transaction Value (ETH)</label>
            <input type="number" id="minValue" value="0.1" step="0.1" min="0">
        </div>

        <div class="control-group">
            <label for="gasThreshold">Min Gas Price (Gwei)</label>
            <input type="number" id="gasThreshold" value="20" step="1" min="0">
        </div>

        <div class="control-group">
            <button class="btn" id="analyzeBtn" onclick="analyzeMEVActivity()">
                Analyze MEV Activity
            </button>
        </div>

        <div id="errorContainer"></div>
    </div>

    <div id="network-container">
        <div class="loading" id="loadingIndicator" style="display: none;">
            <div class="spinner"></div>
            <div>Analyzing blockchain data...</div>
        </div>
    </div>

    <div class="stats" id="statsContainer" style="display: none;">
        <div class="stat-card">
            <div class="stat-value" id="totalBots">0</div>
            <div class="stat-label">MEV Bots Detected</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="totalTransactions">0</div>
            <div class="stat-label">Suspicious Transactions</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="totalValue">0</div>
            <div class="stat-label">Total Value (ETH)</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="avgGasPrice">0</div>
            <div class="stat-label">Avg Gas Price (Gwei)</div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #00d4ff;"></div>
            <span>MEV Bot</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #10b981;"></div>
            <span>Regular User</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f59e0b;"></div>
            <span>High-Value Transaction</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>Suspicious Activity</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let web3;
        let scene, camera, renderer;
        let nodes = [];
        let connections = [];
        let animationId;
        let isConnected = false;

        // Custom Web3 provider that uses Flask proxy
        class FlaskProxyProvider {
            constructor(flaskUrl) {
                this.flaskUrl = flaskUrl;
            }

            async send(method, params) {
                const rpcRequest = {
                    jsonrpc: '2.0',
                    method: method,
                    params: params || [],
                    id: Date.now()
                };

                try {
                    const response = await fetch(`${this.flaskUrl}/eth-proxy`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(rpcRequest)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(`RPC Error: ${data.error.message}`);
                    }

                    return data.result;
                } catch (error) {
                    console.error('RPC call failed:', error);
                    throw error;
                }
            }

            async sendBatch(requests) {
                try {
                    const response = await fetch(`${this.flaskUrl}/eth-batch-proxy`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requests)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('Batch RPC call failed:', error);
                    throw error;
                }
            }
        }

        // Web3-like interface using our custom provider
        class CustomWeb3 {
            constructor(flaskUrl) {
                this.provider = new FlaskProxyProvider(flaskUrl);
                this.utils = {
                    fromWei: (value, unit) => {
                        const units = {
                            'wei': 1,
                            'gwei': 1e9,
                            'ether': 1e18
                        };
                        return parseFloat(value) / units[unit];
                    },
                    toWei: (value, unit) => {
                        const units = {
                            'wei': 1,
                            'gwei': 1e9,
                            'ether': 1e18
                        };
                        return (parseFloat(value) * units[unit]).toString();
                    },
                    isAddress: (address) => {
                        return /^0x[a-fA-F0-9]{40}$/.test(address);
                    }
                };
                this.eth = {
                    getBlockNumber: () => this.provider.send('eth_blockNumber').then(result => parseInt(result, 16)),
                    getBlock: (blockNumber, includeTransactions) => {
                        const blockParam = typeof blockNumber === 'number' ? '0x' + blockNumber.toString(16) : blockNumber;
                        return this.provider.send('eth_getBlockByNumber', [blockParam, includeTransactions]);
                    },
                    getBalance: (address) => this.provider.send('eth_getBalance', [address, 'latest']),
                    net: {
                        getId: () => this.provider.send('net_version').then(result => parseInt(result))
                    }
                };
            }
        }

        // Initialize Web3 connection through Flask proxy
        async function initWeb3() {
            try {
                // Always use localhost:5000 for the Flask server
                const flaskUrl = 'http://localhost:5000';
                
                web3 = new CustomWeb3(flaskUrl);
                
                // Test connection
                const blockNumber = await web3.eth.getBlockNumber();
                
                // Try to get network ID, but don't fail if not supported
                let networkInfo = '';
                try {
                    const networkId = await web3.eth.net.getId();
                    networkInfo = `, Network: ${networkId}`;
                } catch (netError) {
                    console.log('Network ID not available:', netError.message);
                    networkInfo = '';
                }
                
                document.getElementById('nodeStatus').textContent = 
                    `Connected to Erigon via Flask proxy (Block: ${blockNumber}${networkInfo})`;
                document.getElementById('statusIndicator').style.background = '#10b981';
                isConnected = true;
                
                // Initialize Three.js scene
                initThreeJS();
                
            } catch (error) {
                console.error('Web3 connection failed:', error);
                document.getElementById('nodeStatus').textContent = 
                    'Failed to connect to Flask proxy server';
                document.getElementById('statusIndicator').style.background = '#ef4444';
                showError(`Cannot connect to Flask proxy. Make sure your Flask server is running on port 5000. Error: ${error.message}`);
                isConnected = false;
            }
        }

        // Initialize Three.js visualization
        function initThreeJS() {
            const container = document.getElementById('network-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f23);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 500;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add some ambient particles
            createAmbientParticles();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse interaction
            setupMouseInteraction();
        }

        // Create ambient background particles
        function createAmbientParticles() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 1000;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00d4ff,
                size: 2,
                transparent: true,
                opacity: 0.3
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // Setup mouse interaction
        function setupMouseInteraction() {
            const mouse = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();
            let tooltip = null;
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodes);
                
                // Remove existing tooltip
                if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                }
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData) {
                        showTooltip(event.clientX, event.clientY, object.userData);
                    }
                }
            });
        }

        // Show tooltip with node information
        function showTooltip(x, y, data) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <strong>Address:</strong> ${data.address}<br>
                <strong>Type:</strong> ${data.type}<br>
                <strong>Transactions:</strong> ${data.txCount}<br>
                <strong>Total Value:</strong> ${data.totalValue} ETH<br>
                <strong>Avg Gas:</strong> ${data.avgGas} Gwei
            `;
            tooltip.style.left = x + 10 + 'px';
            tooltip.style.top = y + 10 + 'px';
            document.body.appendChild(tooltip);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (document.body.contains(tooltip)) {
                    tooltip.remove();
                }
            }, 3000);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Rotate camera around the scene
            const time = Date.now() * 0.0001;
            camera.position.x = Math.cos(time) * 300;
            camera.position.z = Math.sin(time) * 300;
            camera.lookAt(scene.position);
            
            // Animate nodes
            nodes.forEach((node, index) => {
                if (node.userData.type === 'mevBot') {
                    node.rotation.y += 0.02;
                    node.position.y += Math.sin(Date.now() * 0.001 + index) * 0.5;
                }
            });
            
            renderer.render(scene, camera);
        }

        // Analyze MEV activity
        async function analyzeMEVActivity() {
            if (!isConnected) {
                showError('Not connected to Ethereum node');
                return;
            }

            const blockRange = parseInt(document.getElementById('blockRange').value);
            const minValue = parseFloat(document.getElementById('minValue').value);
            const gasThreshold = parseFloat(document.getElementById('gasThreshold').value);
            
            const loadingIndicator = document.getElementById('loadingIndicator');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const errorContainer = document.getElementById('errorContainer');
            
            // Reset UI
            loadingIndicator.style.display = 'block';
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'Analyzing...';
            errorContainer.innerHTML = '';
            clearVisualization();
            
            try {
                const currentBlock = await web3.eth.getBlockNumber();
                const startBlock = currentBlock - blockRange;
                
                console.log(`Analyzing blocks ${startBlock} to ${currentBlock}`);
                
                const mevData = await detectMEVActivity(startBlock, currentBlock, minValue, gasThreshold);
                
                if (mevData.bots.length === 0) {
                    showError('No MEV activity detected in the specified range. Try adjusting the parameters.');
                    return;
                }
                
                visualizeMEVNetwork(mevData);
                updateStats(mevData);
                
                document.getElementById('statsContainer').style.display = 'grid';
                
            } catch (error) {
                console.error('MEV analysis error:', error);
                showError(`Analysis failed: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'Analyze MEV Activity';
            }
        }

        // Detect MEV activity in blockchain data
        async function detectMEVActivity(startBlock, endBlock, minValue, gasThreshold) {
            const suspiciousAddresses = new Map();
            const allTransactions = [];
            const blockData = [];
            
            // Process blocks in parallel batches
            const batchSize = 5;
            for (let i = startBlock; i <= endBlock; i += batchSize) {
                const batchPromises = [];
                const batchEnd = Math.min(i + batchSize, endBlock + 1);
                
                for (let blockNum = i; blockNum < batchEnd; blockNum++) {
                    batchPromises.push(analyzeBlock(blockNum, minValue, gasThreshold));
                }
                
                const batchResults = await Promise.all(batchPromises);
                batchResults.forEach(result => {
                    if (result) {
                        blockData.push(result);
                        result.transactions.forEach(tx => {
                            allTransactions.push(tx);
                            
                            // Track suspicious addresses
                            [tx.from, tx.to].forEach(addr => {
                                if (addr) {
                                    if (!suspiciousAddresses.has(addr)) {
                                        suspiciousAddresses.set(addr, {
                                            address: addr,
                                            transactions: [],
                                            totalValue: 0,
                                            totalGas: 0,
                                            suspicionScore: 0
                                        });
                                    }
                                    
                                    const data = suspiciousAddresses.get(addr);
                                    data.transactions.push(tx);
                                    data.totalValue += parseFloat(tx.value);
                                    data.totalGas += parseFloat(tx.gasPrice);
                                }
                            });
                        });
                    }
                });
            }
            
            // Calculate suspicion scores and identify MEV bots
            const mevBots = [];
            suspiciousAddresses.forEach((data, address) => {
                const avgGas = data.totalGas / data.transactions.length;
                const txCount = data.transactions.length;
                const avgValue = data.totalValue / txCount;
                
                // MEV bot heuristics
                let suspicionScore = 0;
                if (avgGas > gasThreshold * 2) suspicionScore += 30; // High gas prices
                if (txCount > blockData.length * 0.1) suspicionScore += 40; // High frequency
                if (avgValue > minValue * 5) suspicionScore += 20; // High value transactions
                
                // Check for sandwich attack patterns
                const hasSandwichPattern = detectSandwichPattern(data.transactions);
                if (hasSandwichPattern) suspicionScore += 50;
                
                data.suspicionScore = suspicionScore;
                
                if (suspicionScore > 50) {
                    mevBots.push({
                        ...data,
                        type: 'mevBot',
                        avgGas: avgGas / 1e9, // Convert to Gwei
                        avgValue: avgValue
                    });
                }
            });
            
            return {
                bots: mevBots,
                transactions: allTransactions,
                blocks: blockData,
                totalValue: allTransactions.reduce((sum, tx) => sum + parseFloat(tx.value), 0)
            };
        }

        // Analyze individual block
        async function analyzeBlock(blockNumber, minValue, gasThreshold) {
            try {
                const block = await web3.eth.getBlock(blockNumber, true);
                if (!block || !block.transactions) return null;
                
                const suspiciousTransactions = block.transactions.filter(tx => {
                    const value = parseFloat(web3.utils.fromWei(tx.value, 'ether'));
                    const gasPrice = parseFloat(web3.utils.fromWei(tx.gasPrice, 'gwei'));
                    
                    return value >= minValue || gasPrice >= gasThreshold;
                }).map(tx => ({
                    ...tx,
                    value: parseFloat(web3.utils.fromWei(tx.value, 'ether')),
                    gasPrice: parseFloat(web3.utils.fromWei(tx.gasPrice, 'gwei')),
                    blockNumber: blockNumber
                }));
                
                return {
                    blockNumber: blockNumber,
                    timestamp: block.timestamp,
                    transactions: suspiciousTransactions,
                    totalTransactions: block.transactions.length
                };
                
            } catch (error) {
                console.error(`Error analyzing block ${blockNumber}:`, error);
                return null;
            }
        }

        // Detect sandwich attack patterns
        function detectSandwichPattern(transactions) {
            if (transactions.length < 3) return false;
            
            // Sort by block number and transaction index
            const sortedTxs = transactions.sort((a, b) => {
                if (a.blockNumber !== b.blockNumber) {
                    return a.blockNumber - b.blockNumber;
                }
                return a.transactionIndex - b.transactionIndex;
            });
            
            // Look for pattern: high gas -> normal gas -> high gas
            for (let i = 0; i < sortedTxs.length - 2; i++) {
                const tx1 = sortedTxs[i];
                const tx2 = sortedTxs[i + 1];
                const tx3 = sortedTxs[i + 2];
                
                if (tx1.gasPrice > tx2.gasPrice * 1.5 && tx3.gasPrice > tx2.gasPrice * 1.5) {
                    return true;
                }
            }
            
            return false;
        }

        // Visualize MEV network
        function visualizeMEVNetwork(mevData) {
            const { bots } = mevData;
            
            // Create nodes for MEV bots
            bots.forEach((bot, index) => {
                const nodeGeometry = new THREE.SphereGeometry(
                    Math.max(5, Math.min(20, bot.suspicionScore / 5)), 32, 32
                );
                
                const nodeMaterial = new THREE.MeshLambertMaterial({
                    color: bot.type === 'mevBot' ? 0x00d4ff : 0x10b981,
                    transparent: true,
                    opacity: 0.8
                });
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                
                // Position nodes in a spiral
                const angle = (index / bots.length) * Math.PI * 4;
                const radius = 100 + (bot.suspicionScore * 2);
                node.position.x = Math.cos(angle) * radius;
                node.position.z = Math.sin(angle) * radius;
                node.position.y = (Math.random() - 0.5) * 100;
                
                // Store metadata
                node.userData = {
                    address: bot.address.substring(0, 10) + '...',
                    type: bot.type,
                    txCount: bot.transactions.length,
                    totalValue: bot.totalValue.toFixed(4),
                    avgGas: bot.avgGas.toFixed(2),
                    suspicionScore: bot.suspicionScore
                };
                
                scene.add(node);
                nodes.push(node);
                
                // Add glow effect for high-suspicion bots
                if (bot.suspicionScore > 70) {
                    const glowGeometry = new THREE.SphereGeometry(
                        node.geometry.parameters.radius * 1.5, 32, 32
                    );
                    const glowMaterial = new THREE.MeshLambertMaterial({
                        color: 0xff4444,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    node.add(glow);
                }
            });
            
            // Create connections between related bots
            for (let i = 0; i < bots.length; i++) {
                for (let j = i + 1; j < bots.length; j++) {
                    const bot1 = bots[i];
                    const bot2 = bots[j];
                    
                    // Check for transaction relationships
                    const hasConnection = bot1.transactions.some(tx1 =>
                        bot2.transactions.some(tx2 => 
                            Math.abs(tx1.blockNumber - tx2.blockNumber) <= 1
                        )
                    );
                    
                    if (hasConnection) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            nodes[i].position,
                            nodes[j].position
                        ]);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xf59e0b,
                            transparent: true,
                            opacity: 0.4
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        connections.push(line);
                    }
                }
            }
        }

        // Update statistics display
        function updateStats(mevData) {
            const { bots, transactions, totalValue } = mevData;
            
            document.getElementById('totalBots').textContent = bots.length;
            document.getElementById('totalTransactions').textContent = transactions.length;
            document.getElementById('totalValue').textContent = totalValue.toFixed(2);
            
            const avgGasPrice = transactions.reduce((sum, tx) => sum + tx.gasPrice, 0) / transactions.length;
            document.getElementById('avgGasPrice').textContent = avgGasPrice.toFixed(2);
        }

        // Clear existing visualization
        function clearVisualization() {
            // Remove nodes
            nodes.forEach(node => {
                scene.remove(node);
            });
            nodes = [];
            
            // Remove connections
            connections.forEach(connection => {
                scene.remove(connection);
            });
            connections = [];
            
            // Hide stats
            document.getElementById('statsContainer').style.display = 'none';
        }

        // Show error message
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initWeb3);
    </script>
</body>
</html>